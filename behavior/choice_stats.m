%%% getChoiceStats
%PURPOSE:   Analyze choice behavior in the discrim/flexibility task
%AUTHORS:   AC Kwan 170518
%           modified by MJ Siniscalchi 190409
%
%INPUT ARGUMENTS
%   trials:  Structure generated by discrim_getTrialMasks().
%
%--------------------------------------------------------------------------

function stats = getChoiceStats(trials)

% trials performed (any with a response, excluding misses)
corrL = (trials.left & trials.hit);
corrR = (trials.right & trials.hit);
stats.nTrialsPerformed=sum(~trials.miss);
stats.nCorrect=sum(corrL) + sum(corrR);
stats.nErr = sum(trials.err);

% overall correct rate
stats.correctRate=(sum(corrL) + sum(corrR))/stats.nTrialsPerformed;

% correct rates for left or right port
stats.correctRateL=sum(corrL)/sum(trials.upsweep & ~trials.miss);
stats.correctRateR=sum(corrR)/sum(trials.downsweep & ~trials.miss);

% correct rate following a certain trial type
trialAfter = [false; trials.hit(1:end-1)];
stats.correctRateAfterHit = sum(trialAfter & (corrL | corrR))/sum(trialAfter & ~trials.miss);
if sum(trials.err) > 0
    trialAfter = [false; trials.err(1:end-1)];
    stats.correctRateAfterErr = sum(trialAfter & (corrL | corrR))/sum(trialAfter & ~trials.miss);
else
    stats.correctRateAfterErr = NaN;
end
trialAfter = [false; trials.miss(1:end-1)];
stats.correctRateAfterMiss = sum(trialAfter & (corrL | corrR))/sum(trialAfter & ~trials.miss);

% fraction miss trials, on trial following a certain trial type
trialAfter = [false; trials.hit(1:end-1)];
stats.missFracAfterHit = sum(trialAfter & trials.miss)/sum(trialAfter);
if sum(trials.err) > 0
    trialAfter = [false; trials.err(1:end-1)];
    stats.missFracAfterErr = sum(trialAfter & trials.miss)/sum(trialAfter);
else
    stats.missFracAfterErr = NaN;
end
trialAfter = [false; trials.miss(1:end-1)];
stats.missFracAfterMiss = sum(trialAfter & trials.miss)/sum(trialAfter);

% d-prime
correctRateLeft = stats.correctRateL;
correctRateRight = stats.correctRateR;
if correctRateLeft==1   %cannot put 0 or 1 as argument for 'norminv' later
    correctRateLeft=0.99;
elseif correctRateLeft==0
    correctRateLeft=0.01;
end
if correctRateRight==1
    correctRateRight=0.99;
elseif correctRateRight==0
    correctRateRight=0.01;
end

stats.dprime=norminv(correctRateLeft)-norminv(1-correctRateRight);
    
%% ---- bias in the overall number of left or right response
stats.fracLeft = sum(trials.left) / (sum(trials.left) + sum(trials.right));

%% ---- analysis of win-stay, lose-switch behavior

oneback = @(trialMask) [false; trialMask(1:end-1)];

% win-stay, lose-switch
ws = oneback(trials.hit) &...
    ((oneback(trials.left) & trials.left) |...
    (oneback(trials.right) & trials.right)); %if they stay after winning prior trial

ws_denom = oneback(trials.hit) & ~trials.miss; %only count if they choose on the current trial

ls = oneback(trials.err) &...
    ((oneback(trials.left) & trials.right) |...
    (oneback(trials.right) & trials.left)); %if they switch after losing prior trial

ls_denom = oneback(trials.err) & ~trials.miss; %only include trials performed

stats.wsRate = sum(ws)./sum(ws_denom); % fraction win-stay out of all wins
stats.lsRate = sum(ls)./sum(ls_denom); % fraction win-stay out of all wins
stats.wslsRate = (sum(ws)+sum(ls))./(sum(ws_denom)+sum(ls_denom)); %fraction win-stay-lose-switch out of all trials

% if there was a response, % of stay
stay = (oneback(trials.left) & trials.left) | (oneback(trials.right) & trials.right); %if they stay on the choice for consecutive trials
stay_denom = oneback(~trials.miss) & ~trials.miss; %only count if they made choices on the current and last trials

stats.stayRate = sum(stay)./sum(stay_denom); % fraction stay

end  