function cells = calc_dFF( cells, stackInfo, logfileTimes, corrFactor )
% % calc_dFF %
%PURPOSE:   Calculate dF/F from raw fluorescence files (generated by the GUI, cellROI.m)
%AUTHORS:   MJ Siniscalchi and AC Kwan 190320
%
%INPUT ARGUMENTS
%   cells:          structure generated by 'calc_cellF.m', containing
%                       'cellID', cell IDs generated by the GUI 'cellROI.m'
%                       'cellF', the corresponding cellular fluorescence time series
%                       'npF', the neuropil (background) fluorescence time series
%   stackInfo:      content of the stackInfo.mat file for this imaging session
%   logfileTimes:   Trigger times from NBS Presentation
%   corrFactor:     scaling factor alpha used for neuropil subtraction, if specified.
%
%OUTPUT ARGUMENTS
%   cells:          a structure containing fields 'cellID','dFF', 't', and 'exclude'
%
%---------------------------------------------------------------------------------------------------
%% Calculate dF/F for each cell: dF/F = (F(t)-F0(t))/F0(t)

% If no correction factor specified, assume no neuropil correction
if nargin < 4
    corrFactor = 0;
end

% Set sliding window to estimate F0 (baseline fluorescence)
win = 10*60*stackInfo.frameRate;  %window duration = 10 minutes
nROIs = numel(cells.cellF);

% Initialize fields for excluded cells & associated criteria 
cells.exclude.cells = [];
cells.exclude.crit = {};

disp('Calculating dF/F...');
for i = 1:nROIs
        
    disp(['Cell ' int2str(i) '/' int2str(nROIs)]);
    
    F = cells.cellF{i}(:);
    neuropilf = cells.npF{i}(:);
    baseline = nan(size(F));
    baseline_NP = nan(size(F));
    for j = 1:length(F)
        idx1 = max(1,round(j-win/2));
        idx2 = min(length(F),round(j+win/2));
        baseline(j) = prctile(F(idx1:idx2),5);              %5th percentile of F(t)
        baseline_NP(j) = prctile(neuropilf(idx1:idx2),5);   %5th percentile of F(t); for neuropil subtraction F0 for ROI must exceed that of neuropil (below)
    end
        
    % Neuropil Subtraction & Exclusion
    if mean(baseline - baseline_NP) > 0 && corrFactor > 0
        %Subtract scaled neuropil signal
        F = F - corrFactor * neuropilf;
        %Set values < baseline to baseline
        F(F<baseline) = baseline(F<baseline);       %To mitigate overcorrection (ie sign-reversed neuropil artifacts)
    elseif mean(baseline - baseline_NP) < 0         %F0 on average is <= neuropil_FO and therefore cannot be accurately estimated
        cells.exclude.cells = [cells.exclude.cells; cells.cellID{i}];   %Store cell ID
        cells.exclude.crit = [cells.exclude.crit; 'npF0>F0'];           %Note exclusion criterion
        continue
    elseif any(isnan(F)) %Should be exclusion mask from cellROI.m
        cells.exclude.cells = [cells.exclude.cells; cells.cellID{i}];   %Store cell ID
        cells.exclude.crit  = [cells.exclude.crit; 'F==NaN'];           %Note exclusion criterion
        continue
    end
    
    % Assign Output Fields    
    cells.dFF{i} = (F-baseline)./(baseline);
end
%Remove empty values and transpose cell array
cells.cellID = cells.cellID(~cellfun(@isempty,cells.dFF));
cells.dFF = cells.dFF(~cellfun(@isempty,cells.dFF));
cells.dFF = cells.dFF(:);
cells = rmfield(cells,{'cellF','npF'});

cells.corrFactor = corrFactor; %Store correction factor with the data

%% Generate time vector for alignment with behavioral events

% Calculate time of each frame in substack
nFrames = stackInfo.nFrames;                        %Number of frames in each trial-indexed substack
stackTimes = logfileTimes - stackInfo.trigDelay;    %Calculate time of first frame in each substack, estimated from timestamps from NBS Presentation
dt = [diff(stackTimes)./nFrames(1:end-1); 1/stackInfo.frameRate]; %Empirical estimate for dt, with nominal dt used for last substack
t = cell([numel(nFrames),1]);
for i = 1:numel(nFrames)
    t{i} = stackTimes(i) + dt(i)*(0:1:(nFrames(i)-1)); %Using empirical estimate for dt
end
cells.t = [t{:}]'; %Concatenate to numeric column vector